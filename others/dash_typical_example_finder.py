# Dashboard for finding typical examples in your data.
# -*- coding: utf-8 -*-
# dashboard / plotting code
import dash
import dash_core_components as dcc
import dash_html_components as html
from dash.exceptions import PreventUpdate

import src.data.compute_similarity as csim

# Data processing code
import os
import pickle as pkl
import glob
import xarray as xr
import numpy as np
import pandas as pd

import src.data.analyse_2p as ana2p
import src.data.xarray_util as xr_util

import datashader as ds
import datashader.transfer_functions as dstf

import plotly.graph_objs as go

import datetime

from flask_caching import Cache

# Trying out dash bootstrap components to make things look better
import dash_bootstrap_components as dbc

# Profiling
import time


# app = dash.Dash(external_stylesheets=[dbc.themes.BOOTSTRAP])
from collections import OrderedDict

colors = {
    'background': '#FFFFFF',
    'text': '#7FDBFF'
}

# Setting up the application

app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])

# TODO: show the heatmap

# TODO: have a UI to allow user to give a score (eg. from 1 - 5)

### NAVIGATION SIDE BAR

# Multipage set up: some id are generated by callbacks
app.config.suppress_callback_exceptions = True

# the style arguments for the sidebar. We use position:fixed and a fixed width
SIDEBAR_STYLE = {
    "position": "fixed",
    "top": 0,
    "left": 0,
    "bottom": 0,
    "width": "16rem",
    "padding": "2rem 1rem",
    "background-color": "#f8f9fa",
}

# the styles for the main content position it to the right of the sidebar and
# add some padding.
CONTENT_STYLE = {
    "margin-left": "18rem",
    "margin-right": "2rem",
    "padding": "2rem 1rem",
}

sidebar = html.Div(
    [
        html.H2("Typical Example Finder", className="display-4"),
        html.Hr(),
        html.P(
            "Pages", className="lead"
        ),
        dbc.Nav(
            [
                dbc.NavLink("Heatmaps", href="/page-1", id="page-1-link"),
                dbc.NavLink("Lines", href="/page-2", id="page-2-link"),
                dbc.NavLink("Settings", href="/page-3", id="page-3-link"),
            ],
            vertical=True,
            pills=True,
        ),
    ],
    style=SIDEBAR_STYLE,
)


page_content = html.Div(id='page-content', style=CONTENT_STYLE)

app.layout = html.Div(style={'backgroundColor': colors['background']}, children=[

    # Url component for get the page
    dcc.Location(id="url"),

    # Navigtation side bar
    sidebar,

    page_content

])

heatmap_page_content = html.Div(children=[
    # Heading
    html.H1(
        children='Finding the perfect heatmap',
        style={
            'textAlign': 'center',
            'color': colors['text']
        }
    ),

    dcc.Upload(
        id='upload-heatmap-data',
        children=html.Div([
            'Drag and Drop or ',
            html.A('Select Files')
        ]),
        style={
            'width': '100%',
            'height': '60px',
            'lineHeight': '60px',
            'borderWidth': '1px',
            'borderStyle': 'dashed',
            'borderRadius': '5px',
            'textAlign': 'center',
            'margin': '10px'
        },

        # Allow multiple files to be uploaded
        multiple=True
    ),

    # Show heatmap of the uploaded data
    html.Div(id='plot-matrix-heatmap-uploaded'),
    dcc.Graph(id='matrix-heatmap'),

    # Range slider for the heatmap
    dcc.RangeSlider(
            id='heatmap-range-slider',
            min=0,
            max=20,
            step=0.5,
            value=[5, 15],
            allowCross=False,
        ),
    html.Div(id='output-container-range-slider'),

    # Progress bar of how many trials you went through
    dbc.Progress(id='matrix-progress-bar'),

    # Rate the graph
    html.H2(children='Rate the heatmap'),

    html.Div(
        [
            dbc.Button("Very good", color="primary", className="mr-1", id='vgood-button'),
            dbc.Button("Good", color="secondary", className="mr-1", id='good-button'),
            dbc.Button("No opinion", color="success", className="mr-1", id='no-opinion-button'),
            dbc.Button("Bad", color="warning", className="mr-1", id='bad-button'),
            dbc.Button("Very bad", color="danger", className="mr-1", id='vbad-button'),
        ]
    ),

    dcc.Store(id='reviewed-heatmap-store', storage_type='session'),

    html.Table([
        html.Tr([
            html.Th('Heatmap index number (Trial)')
        ]),
        html.Tbody([
            html.Td('No data selected', id='reviewed-heatmap-store-table')
        ])
    ]),

    # Recommendation ranking
    html.H2(children='Recommendation ranking'),

    dcc.Graph(id='matrix-similarity-bar')


    ]
)


line_page_content = html.Div(children=[
    # Heading
    html.H1(
        children='Finding the perfect line',
        style={
            'textAlign': 'center',
            'color': colors['text']
        }
    )
    ]
)


data_and_settings_page_content = html.Div(children=[
    # Heading
    html.H1(
        children='Settings and data loading',
        style={
            'textAlign': 'center',
            'color': colors['text']
        }
    ),

    # Data Upload
    html.H2(
        children='Upload your heatmap files here',
        style={
            'textAlign': 'center',
            'color': colors['text']
        }
    ),

    dcc.Upload(
        id='upload-matrix',
        children=html.Div([
            'Drag and Drop or ',
            html.A('Select Files')
        ]),
        style={
            'width': '100%',
            'height': '60px',
            'lineHeight': '60px',
            'borderWidth': '1px',
            'borderStyle': 'dashed',
            'borderRadius': '5px',
            'textAlign': 'center',
            'margin': '10px'
        },
        # Allow multiple files to be uploaded
        multiple=True
    ),

    html.Div(id='print-matrix-data-uploaded'),


]
)


# Side bar callback to highlight the active page
@app.callback(
    [dash.dependencies.Output(f"page-{i}-link", "active") for i in range(1, 4)],
    [dash.dependencies.Input("url", "pathname")],
)
def toggle_active_links(pathname):
    if pathname == "/":
        # Treat page 1 as the homepage / index
        return True, False, False
    return [pathname == f"/page-{i}" for i in range(1,  4)]

# Side bar callback too set the page
@app.callback(dash.dependencies.Output("page-content", "children"),
              [dash.dependencies.Input("url", "pathname")])
def render_page_content(pathname):
    if pathname in ["/", "/page-1"]:
        return heatmap_page_content
    elif pathname == "/page-2":
        return line_page_content
    elif pathname == "/page-3":
        return data_and_settings_page_content
    # If the user tries to reach a different page, return a 404 message
    return dbc.Jumbotron(
        [
            html.H1("404: Not found", className="text-danger"),
            html.Hr(),
            html.P(f"The pathname {pathname} was not recognised..."),
        ]
    )

########################### DEPENCIES FOR SETTINGS PAGE ###############################

# Function to parse the uploaded content
def read_file_and_print_name(contents, filename, date):


    if '.npy' in filename or '.nc' in filename:
        page_output = html.Div([
            html.H5('Filename: ' + filename),
            html.H6('Last modified: ', datetime.datetime.fromtimestamp(date))
        ])
    else:
        page_output = html.Div([
            'Unsupported file format'
        ])

    return page_output



@app.callback(dash.dependencies.Output('print-matrix-data-uploaded', 'children'),
              [dash.dependencies.Input('upload-matrix', 'contents')],
              [dash.dependencies.State('upload-matrix', 'filename'),
               dash.dependencies.State('upload-matrix', 'last_modified')])
def update_read_file_and_print_name(list_of_contents, list_of_names, list_of_dates):
    if list_of_contents is not None:
        print('File uploaded in first callback')
        children = [
            read_file_and_print_name(c, n, d) for c, n, d in
            zip(list_of_contents, list_of_names, list_of_dates)]
        return children

    return []


######################## DEPENDENCIES FOR HEATMAP PAGE ################################

import base64
import io


def plot_xarary_heatmap(dataset, exp_index=0, trial_idx=0, activity_name='firing_rate',
                        heatmap_selected_range=None):

    if 'Exp' in xr_util.get_ds_dim_names(dataset):
        trial_ds = dataset.isel(Exp=exp_index, Trial=trial_idx)
    else:
        trial_ds = dataset.isel(Trial=trial_idx)

    x = trial_ds['PeriEventTime'].values
    y = trial_ds['Cell'].values
    z = trial_ds[activity_name].values

    if heatmap_selected_range is not None:
        heatmap_fig = go.Figure(data=go.Heatmap(
            z=z,
            x=x,
            y=y,
            zmin=heatmap_selected_range[0],
            zmax=heatmap_selected_range[1],
            colorscale='Viridis'))
    else:
        heatmap_fig = go.Figure(data=go.Heatmap(
            z=z,
            x=x,
            y=y,
            colorscale='Viridis'))

    return heatmap_fig


def plot_similarity_bar(average_rank, sort_idx, sorted_indices):

    if average_rank is not None:

        similarity_fig = go.Figure(
            data=go.Bar(
                x=np.arange(len(average_rank)),
                y=average_rank
            ),
            layout={
                'xaxis_title': 'Matrix index',
                'yaxis_title': 'Average recommendation ranking',
            }
        )
    else:
        similarity_fig = {}

    return similarity_fig


def read_file_and_make_heatmap(list_of_contents, list_of_names, trial_idx=0, template_idx=None, template_score=None,
                               heatmap_selected_range=None):

    if len(list_of_contents) > 1:
        page_output = html.Div(['Multi-plot not supported yet'])
        figure = []
    else:
        filename = list_of_names[0]
        content = list_of_contents[0]
        content_type, content_string = content.split(',')
        decoded = base64.b64decode(content_string)
        if '.nc' in filename:
            # xarray_ds = xr.open_dataset(content_string)
            # xarray_ds = xr.open_dataset(io.StringIO(decoded.decode('utf-8')))
            xarray_ds = xr.open_dataset(io.BytesIO(decoded))  # this requires h5netcdf in Python
            tot_num_matrices = len(xarray_ds['Trial'].values)
            # print(xarray_ds)
            start = time.time()
            figure = plot_xarary_heatmap(xarray_ds, trial_idx=trial_idx, heatmap_selected_range=heatmap_selected_range)
            end = time.time()
            print('Plotting time')
            print(end - start)

            page_output = html.Div(['File name: ' + filename])


            if (template_score is not None) and (len(template_idx) > 0):
                # Compute similarity and output the histogram of that
                start = time.time()
                average_rank, sort_idx, sorted_indices = csim.compute_ranking_xr(dataarray=xarray_ds['firing_rate'],
                                        template_idx=template_idx, template_score=template_score,
                                        method='euclid_dist_fast')
                end = time.time()
                print('Rank calculation time')
                print(end - start)

                similarity_fig = plot_similarity_bar(average_rank, sort_idx, sorted_indices)
            else:
                similarity_fig = {}
                sorted_indices = []

        else:
            page_output = html.Div(['File format not supported.'])
            figure = {}

    return page_output, figure, tot_num_matrices, similarity_fig, sorted_indices


def read_file_and_compute_range(list_of_contents, list_of_names):

    if len(list_of_contents) > 1:
        print('Can not do multi dataset min max yet')
    else:
        filename = list_of_names[0]
        content = list_of_contents[0]
        content_type, content_string = content.split(',')
        decoded = base64.b64decode(content_string)
        if '.nc' in filename:
            # xarray_ds = xr.open_dataset(content_string)
            # xarray_ds = xr.open_dataset(io.StringIO(decoded.decode('utf-8')))
            xarray_ds = xr.open_dataset(io.BytesIO(decoded))  # this requires h5netcdf in Python
            xarray_values = xarray_ds['firing_rate'].values

            max_val = np.max(xarray_values)
            min_val = np.min(xarray_values)

    return min_val, max_val

@app.callback([dash.dependencies.Output('plot-matrix-heatmap-uploaded', 'children'),
              dash.dependencies.Output('matrix-heatmap', 'figure'),
              dash.dependencies.Output('reviewed-heatmap-store', 'data'),
              dash.dependencies.Output('matrix-similarity-bar', 'figure')],
              [dash.dependencies.Input('upload-heatmap-data', 'contents'),
               dash.dependencies.Input('vgood-button', 'n_clicks'),
               dash.dependencies.Input('good-button', 'n_clicks'),
               dash.dependencies.Input('no-opinion-button', 'n_clicks'),
               dash.dependencies.Input('bad-button', 'n_clicks'),
               dash.dependencies.Input('vbad-button', 'n_clicks'),
               dash.dependencies.Input('vgood-button', 'n_clicks_timestamp'),
               dash.dependencies.Input('good-button', 'n_clicks_timestamp'),
               dash.dependencies.Input('no-opinion-button', 'n_clicks_timestamp'),
               dash.dependencies.Input('bad-button', 'n_clicks_timestamp'),
               dash.dependencies.Input('vbad-button', 'n_clicks_timestamp'),
               dash.dependencies.Input('heatmap-range-slider', 'value')
                ],
              [dash.dependencies.State('upload-heatmap-data', 'filename'),
               dash.dependencies.State('reviewed-heatmap-store', 'data')])
def update_read_file_and_print_name(list_of_contents, v_good_nclicks=None, good_nclicks=None, bad_nclicks=None,
                                    no_opinion_nclicks=None, vbad_nclicks=None,
                                    vgood_ts=np.nan, good_ts=np.nan, no_op_ts=np.nan, bad_ts=np.nan, vbad_ts=np.nan,
                                    heatmap_selected_range=None,
                                    list_of_names=None, trial_idx_data=None):
    total_num_clicks = 0
    all_button_nclicks = [v_good_nclicks, good_nclicks, no_opinion_nclicks, bad_nclicks, vbad_nclicks]

    # initialise / keep current state of trial_idx_data
    trial_idx_data = trial_idx_data or {'displayed_indices': [], 'num_matrices': None,
                                        'trial_review_score': [], 'last_ranking_indices': [],
                                        'trial_reviewed': [], 'next_index_to_show': 0,
                                        'curr_update_button_clicks': 0,
                                        'last_update_button_clicks': 0,
                                        'matrix_list_max_val': 10,
                                        'matrix_list_min_val': 0}

    # When there is nothing being ranked yet, show the first trial.
    if len(trial_idx_data['last_ranking_indices']) == 0:
        trial_idx = 0
        trial_idx_data['displayed_indices'].append(trial_idx)

    if not all(button is None for button in all_button_nclicks):
        # keep track of the total number of button clicks
        total_num_clicks = sum(filter(None, all_button_nclicks))  # filter out None values
        trial_idx_data['curr_update_button_clicks'] = total_num_clicks

        trial_idx = trial_idx_data['next_index_to_show']
        trial_idx_data['displayed_indices'].append(trial_idx)

        # trial_idx_data = trial_idx

        # update review score
        # Determine which button was pressed and update the score depending on the button
        button_time_stamps = np.array([vgood_ts, good_ts, no_op_ts, bad_ts, vbad_ts], dtype=np.float64)
        max_idx = np.nanargmax(button_time_stamps)

        if (max_idx == 0) or (max_idx == 1):
            trial_idx_data['trial_review_score'].append(1)
        elif max_idx == 2:
            trial_idx_data['trial_review_score'].append(0)
        elif (max_idx == 3) or (max_idx == 4):
            trial_idx_data['trial_review_score'].append(-1)



        print(trial_idx_data)

    if list_of_contents is not None:
        print(heatmap_selected_range)
        # On first upload of the list of matrices (If nothing is reviewed yet), compute the min and max of the matrix
        # list
        if len(trial_idx_data['last_ranking_indices']) == 0:
            matrix_list_max_val, matrix_list_min_val = read_file_and_compute_range(list_of_contents, list_of_names)
            trial_idx_data['matrix_list_max_val'] = matrix_list_max_val
            trial_idx_data['matrix_list_min_val'] = matrix_list_min_val
            # TODO: output slider range using these values to update the slider
            print('Min val: ' + str(matrix_list_min_val))
            print('Max val:' + str(matrix_list_max_val))

        # Only calculate similarity score and output next trial index if this is a button click callback
        # else just replot the current figure but update the range
        if trial_idx_data['curr_update_button_clicks'] > trial_idx_data['last_update_button_clicks']:
            children, figure, tot_num_matrices, similarity_fig, sorted_indices = read_file_and_make_heatmap(
                list_of_contents, list_of_names, trial_idx=trial_idx, template_idx=trial_idx_data['trial_reviewed'],
                                                                     template_score=trial_idx_data['trial_review_score'],
            heatmap_selected_range=heatmap_selected_range)
        else:
            # only do the replotting
            # note one limitation is that the previous similarity fig bar chart will be gone
            print('Only updating the range')
            trial_idx = trial_idx_data['displayed_indices'][-1]
            children, figure, tot_num_matrices, similarity_fig, _ = read_file_and_make_heatmap(
                list_of_contents, list_of_names, trial_idx=trial_idx, template_idx=None,
                        template_score=None,
            heatmap_selected_range=heatmap_selected_range)
            sorted_indices = [trial_idx_data['displayed_indices'][-1]]

        # Update the button clicks
        trial_idx_data['last_update_button_clicks'] = trial_idx_data['curr_update_button_clicks']

        trial_idx_data['trial_reviewed'].append(trial_idx)
        trial_idx_data['num_matrices'] = tot_num_matrices
        trial_idx_data['last_ranking_indices'] = sorted_indices
        if (sorted_indices is not None) and (len(sorted_indices) >= 1):
            trial_idx_data['next_index_to_show'] = sorted_indices[0]
    else:
        children = 'Please select a file.'
        figure = {}
        similarity_fig = {}

    return children, figure, trial_idx_data, similarity_fig



# Update progress bar

@app.callback([dash.dependencies.Output('matrix-progress-bar', 'value'),
               dash.dependencies.Output('matrix-progress-bar', 'children')],
              [dash.dependencies.Input('vgood-button', 'n_clicks'),
               dash.dependencies.Input('good-button', 'n_clicks'),
               dash.dependencies.Input('no-opinion-button', 'n_clicks'),
               dash.dependencies.Input('bad-button', 'n_clicks'),
               dash.dependencies.Input('vbad-button', 'n_clicks')],
              [dash.dependencies.State('reviewed-heatmap-store', 'data')]
              )
def update_progress_bar(vgood_button, good_button, no_op_button, bad_button, vbad_button, trial_idx_data):

    if trial_idx_data is not None:

        progress_bar_value = len(trial_idx_data['trial_reviewed']) / trial_idx_data['num_matrices'] * 100
        progress_bar_text = str(len(trial_idx_data['trial_reviewed'])) + ' / ' + str(trial_idx_data['num_matrices'])

    return progress_bar_value, progress_bar_text


# Arhive
"""
dcc.RadioItems(
    options=[
        {'label': 'Very good (5)', 'value': 5},
        {'label': 'Good (4)', 'value': 4},
        {'label': 'No opinion (3)', 'value': 3},
        {'label': 'Bad (2)', 'value': 2},
        {'label': 'Very bad (2)', 'value': 1}
    ],
    value=3,
    labelStyle={'display': 'inline-block'}
)
"""


@app.callback(dash.dependencies.Output('reviewed-heatmap-store-table'.format('reviewed-heatmap-store'), 'children'),
              # Since we use the data prop in an output,
              # we cannot get the initial data on load with the data prop.
              # To counter this, you can use the modified_timestamp
              # as Input and the data as State.
              # This limitation is due to the initial None callbacks
              # https://github.com/plotly/dash-renderer/pull/81
              [dash.dependencies.Input('reviewed-heatmap-store', 'modified_timestamp')],
              [dash.dependencies.State('reviewed-heatmap-store', 'data')])
def update_trial_idx_table(timestamp, data):

    if timestamp is None:
        raise PreventUpdate

    if data is not None:
        output_string = data['displayed_indices'][-1]
    else:
        output_string = 'No trial selected.'

    return output_string


if __name__ == '__main__':
    app.run_server(debug=True)


